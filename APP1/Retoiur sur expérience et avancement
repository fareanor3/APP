Rédaction : 

Tout d’abord nous nous sommes réparti les fonctions indispensables : Nemo Farre était l’activateur, Gabriel Nierat le barreur, Nina Bourdonnec la gardienne du temps, Loris Allegraud le scribe, Dorian Rakotonanahary le secrétaire et Heshan Kannangara-Koralalage le faiseur de point. A la suite de cela, nous avons parlé du problème que nous allions traiter. Nous en avons résumé qu’il fallait programmer une bataille d’origine puis trois variantes : l’une où il faudra directement avoir face en l’air la carte suivante sans passer par la carte cachée, l’autre où il faudra placer deux cartes l’une à côté de l’autre pour faire le plus grand nombre en utilisant les cartes 1 à 9 et enfin pour la troisième variante, il faudra additionner les points des deux cartes à partir de ce que l’on a fait dans la deuxième variante. Et à chaque fois nous ferons cela en mode infini et en mode normal pour chacune des variantes. 
Pendant la première séance, après avoir pris connaissance du sujet, nous nous sommes posé les questions suivantes : 
●	Comment fait-on pour coder un jeu de bataille classique ?
●	Comment va-t-on faire pour mettre les deux cartes côte à côte et en faire un plus grand nombre ? 
●	Comment va-t-on faire pour additionner les deux cartes ? 
●	Comment mélanger un paquet ? 
●	Comment comparer des valeurs ? 
●	Quelle structure de valeur utilisée ? 
●	Comment va-t-on faire pour intégrer les Pile et les File ?
 A la suite de ça, nous avons décidé de faire le point sur ce que nous savions déjà faire et sur ce que l’on ne savait pas faire. Pour coder ce jeu, nous savions utiliser tous les types de boucles, appeler une fonction, trier la position des valeurs, générer le jeu. En revanche, nous ne pensions pas savoir générer de tuples ni les comparer, faire un système de détection d’égalité pour qu’il y ait bataille, déterminer des class, mélanger et faire un paquet. 
La liste des productions attendue est de : créer un jeu de carte, trois class permettant de gérer plus facilement le jeu, générer le deck, se servir du jeu 2 pour programmer le 3, créer les fonctions pour vérifier qui a gagné après le match, utiliser pile et file. Pour cela, nous avons décidé d’envisager différentes pistes pour avancer dans le traitement comme tester notre programme à chaque fois pour éviter les bugs, se mettre des deadlines et vérifier que chaque fonction fait ce que nous demandons. Pour traiter ce problème, il nous a fallu apprendre ou revoir la gestion de données c’est-à-dire les piles, les files, les fonctions, certains types d’algorithmiques, savoir traiter de la donnée en python, (gérer les compatibilités des data structure), organiser un programme de manière structurée pour que les codes s’appellent sans collision, savoir chercher dans la data base de python 3 pour trouver de solutions (s’ils en présentaient). A la fin de la séance « retour », nous devrons être capable de dire comment fonctionne le programme, savoir le résumer de manière synthétique, adapter le programme en fonction des questions posées par le professeur, dire ce qui ne marchait pas, les problèmes que nous avons rencontrés, décomposer un programme python en plusieurs fichiers, ...
A la fin de la séance 1, nous avons élaborer un plan d’action qui reposait notamment sur tester en boucle nos codes pour vérifier les données qu’on avait prévu. Et pour finir nous nous sommes répartis les tâches à accomplir : créer un jeu de carte avec les couleurs et les valeurs (fonctions tuple (couleur,valeur)), mélanger le jeu, distribuer le jeu, faire un système de détection pour savoir qui va gagner, etc.
Finalement lors de la deuxième séance, dans nos trois variantes, nous voulions essayer d'éviter l'utilisation de class et de la fonction pour la bataille. C’est la raison pour laquelle nous avons décidé de ne pas créer de code bataille mais plutôt de développer un nouveau type de code pour gagner en efficacité et pour se démarquer des autres groupes. Pour cela, nous avons utilisé la boucle while qui compare juste les cas d’infériorités et de supériorités et qui en cas d’égalité la gère au tour suivant afin de définir le gagnant de la bataille. Cela nous est possible grâce à l'implémentation d'un " board " (une liste) qui stocke les cartes des deux joueurs pour les redistribuer par la suite. 

On a eu un gros probleme de reference en voulant utilser des tuples pour les cartes, mais apres des heures de debugages on a donc utiliser choisis d'utiliser des listes pour palier à ce probleme.